# Design Decision 006: jOOQ for Persistence

* Recorded: 2025-10-24
* Recorded by: <petter@vaadin.com>

During my professional career, all business applications have used JPA and either EclipseLink or Hibernate for
persistence. JPA has also been responsible for many gray hairs (or maybe it is my age) and hair loss (from me pulling
out my own hair in frustration).

JPA is good for prototyping and for persisting object graphs - if you have designed your entities with
the object-relational impedance mismatch in mind. Unless your data model is very simple, there is no way of avoiding
your database schema leaking into your Java code. And if you need to write more complex queries or use a database
specific feature, the limitations of JPA quickly become apparent.

In a previous project, we used CQRS to distinguish between entity operations (read and write whole entities, or more
specifically aggregates) and queries (fetch whatever data the UI needs). For entity operations, we used JPA, and for
queries we used jOOQ. We never had any unsolvable problems with the queries, not even with the complex ones. jOOQ has
been on my radar ever since.

## Getting Started with jOOQ

Back in the day, the problem was that jOOQ required some work to set it up. You needed to start with a database schema,
then create the database (using the same database that you were going to use in production), then run a code generator
that would connect to said database and generate the jOOQ Java classes. All this would have to happen before you could
build your project. JPA was much easier to get started with and so it became more or less the default.

Nowadays, getting started with jOOQ is much easier thanks to tools
like [Flyway](https://www.red-gate.com/products/flyway/community/)
and [Testcontainers](https://testcontainers.com/guides/working-with-jooq-flyway-using-testcontainers/). You need to
manage your SQL schema anyway, so you might as well do that from the start. Testcontainers has a Maven plugin that
fires up your database in a Docker image (and if you're using PostgreSQL this is just as fast as using H2), applies
your migration scripts and runs the jOOQ database generator. How to do this is also explained in the Vaadin
documentation (I copy-paste from that page all the time even though I was the one who wrote it).

## Frameworks and Libraries Getting in the Way of Your Code

For a long time now, I have looked at code as art. I can see beauty in a well-structured system, a well-written class,
or even a well-written function. When I code, I produce art. I want to write code that is efficient, easy to read and
understand, easy to test, nice to look at, and difficult to misuse. I also want the code to stand the test of time
(something you definitely can't say about the code I wrote as a kid or even early in my professional career).

I've found the best way to do this is to learn how to utilize your programming language to the fullest, and use the
features that make the most sense (this might not apply to huge languages like C++, mind you). During the past ten
years, Java has gained a lot of new features that I think makes it easier for me to write code that meets all the
ambitions I just mentioned.

Because of this, I really don't like it when frameworks or libraries impose restrictions on what kind of code I can
write. If I use JPA:

* I can't use final or sealed classes.
* I can't use final fields.
* I can't use records.
* I can't use custom types as IDs.
* I have to specify a default constructor (even though it can be non-public).
* I have to design my code around my relational database schema.

However, I also don't have to worry about things like writing SQL and mapping database columns to Java fields. It is,
again, a trade-off.

jOOQ gives me a modern, strongly typed Java API for building SQL queries, and stays out of my way. I have to write
everything myself, which means I get to decide exactly what my domain model is going to look like, what my relational
database schema is going to look like, and how I'm going to map between these to. It is both a curse and a blessing. It
requires more work and more coding, while giving more explicitness and more control. As I have matured in my career, I
have
started to value explicitness and control over auto-magic.

## Why I Picked jOOQ for Whereabouts

As far as I know, we have only used JPA in all our example applications so far. Still, we have many users who are
already using jOOQ and many more who would probably benefit from using it, if they knew how. As my previous experience
with jOOQ comes from a project where we used both JPA and jOOQ, I wanted to see what it takes to build a complete
Vaadin business application using jOOQ for *everything* in the persistence layer. And that is why I decided to use
jOOQ for Whereabouts.

## ... But What About QueryDSL?

I have tried QueryDSL once in a customer project. It worked well for the first months. Then, as the queries we had to
write started to become more and more complex, its limitations became apparent. We ended up spending hours fighting with
QueryDSL and started longing for something like jOOQ, but were too deep into the project to change. I'm not saying
QueryDSL is bad; maybe we were holding it wrong. And it did work for many of our use cases. But personally, if I was to
start developing a new business application tomorrow, I would not pick it.
